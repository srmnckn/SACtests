#include <cstdlib>
#include <iostream>
#include <ctime>
#include <vector>
#include <stdint.h>
#include <iomanip>
#include<time.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <fstream>
#include <random>
#include <bitset>
//#include <boost/math/distributions/chi_squared.hpp>


typedef uint64_t u64;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
#define NUM_ROUNDS 9 //CHANGE ACCORDING TO THE ROW

using namespace std;
void syspause()
{
	std::cout << "\nPress enter...\n";
	std::cin.clear();
	std::cin.ignore();
	std::cin.get();
}


double chi_squared(const std::vector<int>& observed, const std::vector<double>& expected) {
	double chi_squared = 0.0;
	double diff = 0.0;
	for (int i = 0; i < observed.size(); i++) {  

		diff = static_cast<double>(observed[i] - expected[i]);
		chi_squared += (diff * diff) / static_cast<double>(expected[i]);
	}
	return chi_squared;
}



//S box table
const u8 SBOX[16] =
{
  0xC, 0x5, 0x6, 0xB,
  0x9, 0x0, 0xA, 0xD,
  0x3, 0xE, 0xF, 0x8,
  0x4, 0x7, 0x1, 0x2
};


const u8 PERMUTATION[64] =
{
   0, 16, 32, 48,  1, 17, 33, 49,
   2, 18, 34, 50,  3, 19, 35, 51,
   4, 20, 36, 52,  5, 21, 37, 53,
   6, 22, 38, 54,  7, 23, 39, 55,
   8, 24, 40, 56,  9, 25, 41, 57,
  10, 26, 42, 58, 11, 27, 43, 59,
  12, 28, 44, 60, 13, 29, 45, 61,
  14, 30, 46, 62, 15, 31, 47, 63
};

u64 AddRoundKey(u64 State, u64 RoundKey)
{
	return State ^ RoundKey;
}

u64 Substitution(u64 State)
{
	u64 Result = 0;
	for (int i = 0; i < 16; ++i)
	{
		Result ^= ((u64)SBOX[(State >> (4 * i)) & 0xF] << (4 * i));
	}
	return Result;
}

u64 Permutation(u64 State)
{
	u64 Result = 0;
	for (int i = 0; i < 64; ++i)
	{
		Result ^= (((State >> i) & 1) << PERMUTATION[i]);
	}
	return Result;
}

void CyclicShift61(u64* LastRound, u64* NextRound)
{
	NextRound[0] = (LastRound[1] >> 3) & 0xFFFF;
	NextRound[1] = (LastRound[1] << 61) ^ (LastRound[0] << 45) ^
		(LastRound[1] >> 19);
}


void GenerateRoundKeys(u64* UserKey, u64* RoundKeys, int numRounds = NUM_ROUNDS)
{
	RoundKeys[0] = UserKey[0];
	RoundKeys[1] = UserKey[1];
	for (int i = 1; i <= numRounds; ++i)
	{
		CyclicShift61(&RoundKeys[2 * i - 2], &RoundKeys[2 * i]);
		RoundKeys[2 * i + 1] =
			((u64)SBOX[RoundKeys[2 * i + 1] >> 60] << 60) ^
			(RoundKeys[2 * i + 1] & 0x0FFFFFFFFFFFFFFFULL);
		RoundKeys[2 * i] ^= ((u64)(i & 1) << 15);
		RoundKeys[2 * i + 1] ^= (u64)(i >> 1);
	}
}



u64 Encrypt(u64 plaintext, u64* UserKey, int numRounds = NUM_ROUNDS)
{
	u64 RoundKeys[64] = { 0 };
	GenerateRoundKeys(UserKey, RoundKeys);
	for (int i = 0; i < numRounds; ++i)
	{
		plaintext = Permutation(Substitution(
			AddRoundKey(plaintext, RoundKeys[2 * i + 1])));
	}
	return AddRoundKey(plaintext, RoundKeys[numRounds * 2 + 1]);
}





int main()
{
	int numRounds = NUM_ROUNDS;
	u64 UserKey[2] = { 0x0000000000000000, 0x0000000000000000 }; // 00000000 00000000 0000

	const char* filename = "present_plaintext.txt";
	/*FILE* plaintext_file = nullptr; // Dosya işaretçisi
	errno_t err = fopen_s(&plaintext_file, "present_plaintext.txt", "w"); // fopen_s kullanımı
	if (err != 0 || !plaintext_file) {
		perror("Dosya açma hatası");
		return 1;
	}
	srand((unsigned)time(NULL));
	for (int i = 0; i < 1048576; ++i) {
		uint64_t random_number = ((uint64_t)rand() << 32) | rand(); // 64 bit sayı üret
		std::bitset<64> binary_representation(random_number); // Binary formatına çevir
		fprintf(plaintext_file, "%s\n", binary_representation.to_string().c_str());
	}

	printf("Plaintextler present_plaintext.txt dosyasına yazıldı.\n");
	fclose(plaintext_file);
	*/

	std::ifstream infile(filename);
	if (!infile.is_open()) {
		std::cerr << "Unable to open the file txt" << std::endl;
		return 1;
	}


	std::string line;
	std::vector<std::string> lines;
	std::bitset<64> c_prime;

	while (std::getline(infile, line)) {
		if (line.length() == 64) {
			lines.push_back(line);
		}
		else {
			std::cerr << "Invalid bitset length" << std::endl;
		}
	}

	std::vector<u64> original_results(lines.size());
	for (size_t i = 0; i < lines.size(); ++i) {
		u64 plaintext = std::bitset<64>(lines[i]).to_ullong(); 
		//////std::cout << "Original_M_" << i + 1 << ": " << lines[i] << std::endl;
		original_results[i] = Encrypt(plaintext, UserKey, numRounds);
	}

	infile.close();


	std::vector<std::vector<int>> Matrix(64, std::vector<int>(64, 0));


	for (size_t i = 0; i < lines.size(); ++i) {
		std::string original_line = lines[i];
		for (int j = 0; j < 64; ++j) {
			std::string modified_line = original_line;
			modified_line[j] = (original_line[j] == '0') ? '1' : '0';
			u64 modified_plaintext = std::bitset<64>(modified_line).to_ullong();
			/////////std::cout << "processed_M_" << i + 1 << "," << j << ":    " << modified_line << std::endl;
			u64 c_prime = Encrypt(modified_plaintext, UserKey, numRounds);
			std::bitset<64> xored_result(original_results[i] ^ c_prime);
			for (int k = 63; k >= 0; --k) {
				if (xored_result[k] == 1) {
					Matrix[j][63 - k] += 1;
				}
			}
		}
	}

	std::ofstream outfile("r..matrix_result.txt");
	if (outfile.is_open()) {
		for (int j = 63; j >= 0; --j) {
			for (int k = 63; k >= 0; --k) {
				outfile << Matrix[j][k];
				outfile << " ";

			}
			outfile << std::endl;
		}
		outfile.close();
		std::cout << "Matrix result successfully written to matrix_result.txt" << std::endl;
	}
	else {
		std::cerr << "Unable to open file for writing." << std::endl;
	}


	for (int j = 63; j >= 0; --j) {
		for (int k = 63; k >= 0; --k) {
			std::cout << Matrix[j][k] << " ";
		}
		std::cout << std::endl;
	}


	std::ofstream outfile1("Chi-square-values..r.txt");


	std::vector<double> expected = { 8, 8, 8, 8, 8, 8, 8, 8 };
	

	if (outfile1.is_open()) {



			for (int col = 0; col<64; ++col) { 
				std::vector<int> flattened_col;
				for (int row = 0; row < 64; ++row) {
					flattened_col.push_back(Matrix[row][col]); 
				}

			int bin1 = 0, bin2 = 0, bin3 = 0, bin4 = 0, bin5 = 0, bin6 = 0, bin7 = 0, bin8 = 0;

			for (const auto& value : flattened_col) {
				if (value >= 0 && value <= 523700) {
					bin1++;
				}
				else if (value >= 523701 && value <= 523944) {
					bin2++;
				}
				else if (value >= 523945 && value <= 524125) {
					bin3++;
				}
				else if (value >= 524126 && value <= 524288) {
					bin4++;
				}
				else if (value >= 524289 && value <= 524452) {
					bin5++;
				}
				else if (value >= 524453 && value <= 524634) {
					bin6++;
				}
				else if (value >= 524635 && value <= 524878) {
					bin7++;
				}
				else if (value >= 524879 && value <= 1048576) {
					bin8++;
				}
			}



			outfile1 << "Column " << 63-col << " Bin 1: " << bin1 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 2: " << bin2 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 3: " << bin3 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 4: " << bin4 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 5: " << bin5 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 6: " << bin6 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 7: " << bin7 << std::endl;
			outfile1 << "Column " << 63-col << " Bin 8: " << bin8 << std::endl;

			std::vector<int> observed = { bin1, bin2, bin3, bin4, bin5, bin6, bin7, bin8 };

			double chi_squared_value = chi_squared(observed, expected);

			outfile1 << "Chi-squared_" << 63-col << ": " << chi_squared_value << std::endl;

			//std::cout << "Chi-squared_%d: "<<row << chi_squared_value << std::endl;
			printf("Chi-squared_%d: %f\n", 63-col, chi_squared_value);



		}

		outfile1.close();
		std::cout << "Chi-squared values written to Chi-square-values.txt" << std::endl;
	}
	else {
		std::cerr << "Unable to open file for writing." << std::endl;
	}



	return 0;
}